diff --git a/atom.cpp b/atom.cpp
index 35369fd..304e8bc 100644
--- a/atom.cpp
+++ b/atom.cpp
@@ -7,6 +7,17 @@ Iterator * Term::createIterator(){
   return new NullIterator(this);
 }
 
+
+Iterator * Term::createDFSIterator()
+{
+  return new NullIterator(this);
+}
+
+Iterator * Term::createBFSIterator()
+{
+  return new NullIterator(this);
+}
+
 bool Term::match(Term & a){
   if (typeid(a) ==  typeid(Variable))
     return a.match(*this);
diff --git a/atom.h b/atom.h
index 426e197..a0687a6 100644
--- a/atom.h
+++ b/atom.h
@@ -12,6 +12,8 @@ public:
   virtual string value() const {return symbol();}
   virtual bool match(Term & a);
   virtual Iterator * createIterator();
+  virtual Iterator * createDFSIterator();
+  virtual Iterator * createBFSIterator();
 protected:
   Term ():_symbol(""){}
   Term (string s):_symbol(s) {}
diff --git a/iterator.h b/iterator.h
index ed1397c..1df0e7e 100644
--- a/iterator.h
+++ b/iterator.h
@@ -1,8 +1,14 @@
 #ifndef ITERATOR_H
 #define ITERATOR_H
 
+#include <stack>
+#include <iostream>
+#include <algorithm>
 #include "struct.h"
 #include "list.h"
+#include <queue>
+
+using namespace std;
 
 class Iterator {
 public:
@@ -73,4 +79,104 @@ private:
   int _index;
   List* _list;
 };
+
+class DFSIterator : public Iterator{
+public:
+  DFSIterator(Term* term):_term(term),_index(0){
+    
+  }
+   void first(){
+    _index = 0;
+    Term* term;
+    std::stack<Term*> stk;
+    std::vector<Term*> rev;
+    stk.push(_term);
+    
+    while(!stk.empty()){
+      term = stk.top();
+      stk.pop();
+      if(_term!=term){
+        _dfsTerms.push_back(term);
+      }
+       
+      Iterator * it=term->createIterator();
+      
+      rev.clear();
+      for(it->first();!it->isDone();it->next()){
+        rev.push_back(it->currentItem());
+      }
+      std::reverse(rev.begin(),rev.end());
+      for(int i=0;i<rev.size();i++){
+        stk.push(rev[i]);
+      }
+
+    }
+   }
+   void next(){
+    _index++;
+   }
+   Term* currentItem() const{
+    return _dfsTerms[_index];
+   }
+   bool isDone() const{
+    return _index >= _dfsTerms.size();
+   }
+  private:
+    std::vector<Term*> _dfsTerms;
+    Term* _term;
+    int _index;
+};
+
+class BFSIterator : public Iterator {
+public:
+  BFSIterator(Term* term):_term(term),_index(0){
+    
+  }
+   void first(){
+     Term * term;
+     _index = 0;
+     queue<Term*> que;
+     que.push(_term);
+     while(!que.empty()) {
+      term = que.front();
+      que.pop();
+
+      if(_term!=term){
+        _bfsTerms.push_back(term);
+      }
+      Iterator * it=term->createIterator();
+      for(it->first();!it->isDone();it->next()){
+        que.push(it->currentItem());
+      }
+      // List * l = dynamic_cast<List*> (term);
+      // Struct * s = dynamic_cast<Struct*> (term);
+      // if(s){
+      //   for (int i = 0; i < s->arity(); i++){
+      //     que.push(s->args(i));
+      //   }
+      // }else if (l){
+      //   for (int i = 0; i < l->arity(); i++){
+      //     que.push(l->args(i));
+      //   }
+      // }
+
+     }
+   }
+   void next(){
+    _index++;
+   }
+   Term* currentItem() const{
+    return _bfsTerms[_index];
+   }
+   bool isDone() const{
+     return _index >= _bfsTerms.size();
+    }
+
+    
+  private:
+    std::vector<Term*> _bfsTerms;
+    Term* _term;
+    int _index;
+
+};
 #endif
diff --git a/list.cpp b/list.cpp
index f2c34fb..3823749 100644
--- a/list.cpp
+++ b/list.cpp
@@ -4,6 +4,7 @@
 #include <iostream>
 #include <string>
 #include "list.h"
+#include "iterator.h"
 using std::vector;
 
 string List::symbol() const{
@@ -85,3 +86,13 @@ List * List::tail() const {
     List *ls= new List(_clone_elements) ;
     return ls;
 }
+Iterator*  List::createIterator(){
+    return new ListIterator(this);
+}
+Iterator * List::createDFSIterator(){
+    return new DFSIterator(this);
+}
+  
+Iterator * List::createBFSIterator(){
+    return new BFSIterator(this);
+}
diff --git a/list.h b/list.h
index 235a72f..2da5d00 100644
--- a/list.h
+++ b/list.h
@@ -24,6 +24,10 @@ public:
     return _elements[index];
   }
   int arity() const {return _elements.size();}
+  Iterator* createIterator();
+  Iterator* createDFSIterator();
+  Iterator* createBFSIterator();
+
 private:
   vector<Term *> _elements;
 };
diff --git a/makefile b/makefile
index 1d66755..6667be8 100644
--- a/makefile
+++ b/makefile
@@ -1,4 +1,4 @@
-all: madRace utAtom utVariable utScanner
+all: madRace utAtom utVariable utScanner utIterator
 
 madRace: mainMadRace.o
 	g++ -o madRace mainMadRace.o -lgtest -lpthread
diff --git a/posd2017f b/posd2017f
new file mode 160000
index 0000000..c193929
--- /dev/null
+++ b/posd2017f
@@ -0,0 +1 @@
+Subproject commit c1939294586ff983e9ffd9d3626eea19ea68c59e
diff --git a/struct.cpp b/struct.cpp
index 3152c10..22b6991 100644
--- a/struct.cpp
+++ b/struct.cpp
@@ -4,3 +4,11 @@ Iterator * Struct::createIterator()
 {
   return new StructIterator(this);
 }
+Iterator * Struct::createDFSIterator(){
+  return new DFSIterator(this);
+}
+
+Iterator * Struct::createBFSIterator(){
+  return new BFSIterator(this);
+}
+
diff --git a/struct.h b/struct.h
index 5f8dc99..40b6446 100644
--- a/struct.h
+++ b/struct.h
@@ -41,6 +41,8 @@ public:
   }
   int arity() const {return _args.size();}
   Iterator * createIterator();
+  Iterator* createDFSIterator();
+  Iterator* createBFSIterator();
 private:
   Atom _name;
   std::vector<Term *> _args;
diff --git a/utIterator b/utIterator
old mode 100644
new mode 100755
index 115fa6d..4f2fa0d
Binary files a/utIterator and b/utIterator differ
diff --git a/utIterator.h b/utIterator.h
index df2ddef..d69ee1d 100644
--- a/utIterator.h
+++ b/utIterator.h
@@ -6,6 +6,7 @@
 #include "atom.h"
 #include "list.h"
 #include "iterator.h"
+
 TEST(iterator, first) {
     Number one(1);
     Variable X("X");
@@ -29,28 +30,28 @@ TEST(iterator, first) {
     ASSERT_TRUE(itStruct->isDone());
 }
 
-// TEST(iterator, nested_iterator) {
-//   Number one(1);
-//   Variable X("X");
-//   Variable Y("Y");
-//   Number two(2);
-//   Struct t(Atom("t"), { &X, &two });
-//   Struct s(Atom("s"), { &one, &t, &Y });
-  // StructIterator it(&s);
-  // it.first();
-  // it.next();
-  // Struct *s2 = dynamic_cast<Struct *>(it.currentItem());
-
-  // StructIterator it2(s2);
-  // it2.first();
-  // ASSERT_EQ("X", it2.currentItem()->symbol());
-  // ASSERT_FALSE(it2.isDone());
-  // it2.next();
-  // ASSERT_EQ("2", it2.currentItem()->symbol());
-  // ASSERT_FALSE(it2.isDone());
-  // it2.next();
-  // ASSERT_TRUE(it2.isDone());
-// }
+TEST(iterator, nested_iterator) {
+  Number one(1);
+  Variable X("X");
+  Variable Y("Y");
+  Number two(2);
+  Struct t(Atom("t"), { &X, &two });
+  Struct s(Atom("s"), { &one, &t, &Y });
+  Iterator *it = s.createIterator();
+  it->first();
+  it->next();
+  Struct *s2 = dynamic_cast<Struct *>(it->currentItem());
+
+  Iterator *it2 = s2->createIterator();
+  it2->first();
+  ASSERT_EQ("X", it2->currentItem()->symbol());
+  ASSERT_FALSE(it2->isDone());
+  it2->next();
+  ASSERT_EQ("2", it2->currentItem()->symbol());
+  ASSERT_FALSE(it2->isDone());
+  it2->next();
+  ASSERT_TRUE(it2->isDone());
+}
 
 TEST(iterator, firstList) {
     Number one(1);
@@ -83,6 +84,116 @@ TEST(iterator, NullIterator){
   ASSERT_TRUE(it->isDone());
 }
 
+TEST(iterator, AtomTreeIterator)
+{
+  Atom atom("atom");
+  Iterator *it = atom.createDFSIterator();
+  it->first();
+  ASSERT_TRUE(it->isDone());
+
+  it = atom.createBFSIterator();
+  it->first();
+  ASSERT_TRUE(it->isDone());
+
+
+}
+
+TEST(iterator,TreeDfsIterator){
+  Number _1(1) , _2(2);
+  Variable X("X");
+  vector<Term*> v = {&_1,&_2};
+  Struct t(Atom("t"), v);
+  vector<Term*> v2 = {&_1,&t,&X};
+  Struct s(Atom("s"), v2);
+  Iterator *it = s.createDFSIterator();
+  it->first();
+  ASSERT_EQ("1", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("t(1, 2)", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("1", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("2", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("X", it->currentItem()->symbol());
+  it->next();
+  ASSERT_TRUE(it->isDone());
+}
 
+TEST(iterator,TreeDfsIteratorEmpty){
+  vector<Term*> v = {};
+  Struct t(Atom("t"), v);
+  Iterator *it = t.createDFSIterator();
+  it->first();
+  ASSERT_TRUE(it->isDone());
+}
+
+TEST(iterator, TreeBFSIterator) {
+  Number _1(1) , _2(2);
+  Variable X("X");
+  vector<Term*> v = {&_1,&_2};
+  Struct t(Atom("t"), v);
+  vector<Term*> v2 = {&_1,&t,&X};
+  Struct s(Atom("s"), v2);
+  Iterator *it = s.createBFSIterator();
+  it->first();
+  ASSERT_EQ("1",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("t(1, 2)",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("X",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("1",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("2",it->currentItem()->symbol());
+  it->next();
+  ASSERT_TRUE(it->isDone());
+
+  
+}
+
+TEST (iterator, TreeBFSIteratorList) {
+  Number _1(1) , _2(2);
+  Variable X("X");
+  vector<Term*> v = {&_1,&_2};
+  Struct t(Atom("t"), v);
+  vector<Term*> v2 = {&_1,&t,&X};
+  List l(v2);
+  Iterator *it = l.createBFSIterator();
+  it->first();
+  ASSERT_EQ("1",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("t(1, 2)",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("X",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("1",it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("2",it->currentItem()->symbol());
+  it->next();
+  ASSERT_TRUE(it->isDone());
+}
+
+TEST (iterator, TreeDFSIteratorList) {
+  Number _1(1) , _2(2);
+  Variable X("X");
+  vector<Term*> v = {&_1,&_2};
+  Struct t(Atom("t"), v);
+  vector<Term*> v2 = {&_1,&t,&X};
+  List l(v2);
+  Iterator *it = l.createDFSIterator();
+  it->first();
+  ASSERT_EQ("1", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("t(1, 2)", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("1", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("2", it->currentItem()->symbol());
+  it->next();
+  ASSERT_EQ("X", it->currentItem()->symbol());
+  it->next();
+  ASSERT_TRUE(it->isDone());
+}
 
 #endif
